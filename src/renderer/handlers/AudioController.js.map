{"version":3,"file":"AudioController.js","sourceRoot":"","sources":["AudioController.ts"],"names":[],"mappings":";AAAA,0DAA0D;AAC1D,0CAA0C;AAC1C,oEAAoE;AACpE,0GAA0G;AAE1G,+DAA+D;AAC/D,8BAA8B;AAC9B,wBAAwB;AAExB,wBAAwB;AACxB,6CAA6C;AAC7C,mCAAmC;AACnC,6BAA6B;AAC7B,6BAA6B;AAC7B,iBAAiB;AACjB,6BAA6B;AAC7B,OAAO;AAEP,sFAAsF;AAEtF,4CAA4C;AAC5C,KAAK;AAEL,2DAA2D;AAC3D,yCAAyC;AACzC,8DAA8D;AAC9D,iDAAiD;AACjD,yCAAyC;AAEzC,wCAAwC;AACxC,4DAA4D;AAC5D,uCAAuC;AACvC,wCAAwC;AACxC,2DAA2D;AAE3D,2BAA2B;AAC3B,qCAAqC;AACrC,kCAAkC;AAClC,yBAAyB;AACzB,2BAA2B;AAE3B,yBAAyB;AACzB,uBAAuB;AACvB,8BAA8B;AAC9B,yBAAyB;AACzB,iCAAiC;AACjC,sCAAsC;AACtC,2BAA2B;AAC3B,kEAAkE;AAClE,uEAAuE;AACvE,uEAAuE;AACvE,6CAA6C;AAE7C,aAAa;AACb,uBAAuB;AACvB,4BAA4B;AAC5B,qCAAqC;AACrC,WAAW;AACX,UAAU;AACV,iBAAiB;AACjB,OAAO;AACP,KAAK;AAEL,mCAAmC;AACnC,sGAAsG;AACtG,4DAA4D;AAC5D,oDAAoD;AACpD,aAAa;AACb,MAAM;AACN,6CAA6C;AAC7C,0CAA0C;AAC1C,4CAA4C;AAC5C,sCAAsC;AAEtC,+EAA+E;AAC/E,qEAAqE;AACrE,0CAA0C;AAC1C,0BAA0B;AAC1B,2BAA2B;AAC3B,aAAa;AAEb,2BAA2B;AAC3B,2BAA2B;AAC3B,aAAa;AAEb,2BAA2B;AAC3B,2BAA2B;AAE3B,gDAAgD;AAChD,0BAA0B;AAC1B,4BAA4B;AAC5B,QAAQ;AAER,oDAAoD;AACpD,iDAAiD;AACjD,4BAA4B;AAC5B,QAAQ;AAER,aAAa;AAEb,gCAAgC;AAChC,uBAAuB;AACvB,2BAA2B;AAE3B,oDAAoD;AACpD,iDAAiD;AACjD,4BAA4B;AAC5B,QAAQ;AACR,aAAa;AAEb,6BAA6B;AAC7B,cAAc;AACd,2BAA2B;AAC3B,aAAa;AACb,MAAM;AAEN,uEAAuE;AACvE,uEAAuE;AACvE,kEAAkE;AAClE,KAAK;AAEL,oDAAoD;AACpD,8DAA8D;AAC9D,wEAAwE;AACxE,KAAK;AAEL,qDAAqD;AACrD,uCAAuC;AACvC,aAAa;AACb,MAAM;AACN,2DAA2D;AAC3D,oDAAoD;AACpD,qDAAqD;AACrD,uEAAuE;AACvE,8CAA8C;AAC9C,eAAe;AACf,qBAAqB;AACrB,uBAAuB;AACvB,4DAA4D;AAC5D,mCAAmC;AACnC,4CAA4C;AAC5C,oCAAoC;AACpC,KAAK;AAEL,gDAAgD;AAChD,sBAAsB;AACtB,6DAA6D;AAC7D,8CAA8C;AAC9C,mBAAmB;AACnB,eAAe;AACf,qDAAqD;AACrD,6BAA6B;AAC7B,SAAS;AACT,SAAS;AACT,KAAK;AACL,IAAI;AAEJ,wDAAwD","sourcesContent":["// import { EventEmitter as EventEmitterO } from 'events';\n// import * as io from 'socket.io-client';\n// import { AmongUsState, GameState, Player } from './AmongUsState';\n// import { SocketElementMap, SocketElement, Client, AudioElement, IDeviceInfo } from './smallInterfaces';\n\n// export default class AudioController extends EventEmitterO {\n// \taudioDeviceId = 'default';\n// \tstream: MediaStream;\n\n// \tasync startAudio() {\n// \t\tconst audio: MediaTrackConstraintSet = {\n// \t\t\tdeviceId: this.audioDeviceId,\n// \t\t\tautoGainControl: false,\n// \t\t\techoCancellation: true,\n// \t\t\tlatency: 0,\n// \t\t\tnoiseSuppression: true,\n// \t\t};\n\n// \t\tthis.stream = await navigator.mediaDevices.getUserMedia({ video: false, audio });\n\n// \t\tconsole.log('connected to microphone');\n// \t}\n\n// \tcreateAudioElement(stream: MediaStream): AudioElement {\n// \t\tconsole.log('[createAudioElement]');\n// \t\tconst htmlAudioElement = document.createElement('audio');\n// \t\tdocument.body.appendChild(htmlAudioElement);\n// \t\thtmlAudioElement.srcObject = stream;\n\n// \t\tconst context = new AudioContext();\n// \t\tconst source = context.createMediaStreamSource(stream);\n// \t\tconst gain = context.createGain();\n// \t\tconst pan = context.createPanner();\n// \t\tconst compressor = context.createDynamicsCompressor();\n\n// \t\tpan.refDistance = 0.1;\n// \t\tpan.panningModel = 'equalpower';\n// \t\tpan.distanceModel = 'linear';\n// \t\tpan.maxDistance = 6;\n// \t\tpan.rolloffFactor = 1;\n\n// \t\tsource.connect(pan);\n// \t\tpan.connect(gain);\n// \t\tgain.connect(compressor);\n// \t\tgain.gain.value = 0;\n// \t\thtmlAudioElement.volume = 1;\n// \t\tconst audioContext = pan.context;\n// \t\tconst panPos = [3, 0];\n// \t\tpan.positionZ.setValueAtTime(-0.5, audioContext.currentTime);\n// \t\tpan.positionX.setValueAtTime(panPos[0], audioContext.currentTime);\n// \t\tpan.positionY.setValueAtTime(panPos[1], audioContext.currentTime);\n// \t\tcompressor.connect(context.destination);\n\n// \t\treturn {\n// \t\t\thtmlAudioElement,\n// \t\t\taudioContext: context,\n// \t\t\tmediaStreamAudioSource: source,\n// \t\t\tgain,\n// \t\t\tpan,\n// \t\t\tcompressor,\n// \t\t};\n// \t}\n\n// \t// move to different controller\n// \tupdateAudioLocation(currentGameState: AmongUsState, element: SocketElement, localPLayer: Player) {\n// \t\t//\t\tconsole.log('updateAudioLocation ->', { element });\n// \t\tif (!element.audioElement || !element.client) {\n// \t\t\treturn;\n// \t\t}\n// \t\t//\tconsole.log('[updateAudioLocation]');\n// \t\tconst pan = element.audioElement.pan;\n// \t\tconst gain = element.audioElement.gain;\n// \t\tconst audioContext = pan.context;\n\n// \t\tconst other = element.player; // this.getPlayer(element.client?.clientId);\n// \t\tlet panPos = [other.x - localPLayer.x, other.y - localPLayer.y];\n// \t\tswitch (currentGameState.gameState) {\n// \t\t\tcase GameState.MENU:\n// \t\t\t\tgain.gain.value = 0;\n// \t\t\t\tbreak;\n\n// \t\t\tcase GameState.LOBBY:\n// \t\t\t\tgain.gain.value = 1;\n// \t\t\t\tbreak;\n\n// \t\t\tcase GameState.TASKS:\n// \t\t\t\tgain.gain.value = 1;\n\n// \t\t\t\t// Mute other players which are in a vent\n// \t\t\t\tif (other.inVent) {\n// \t\t\t\t\tgain.gain.value = 0;\n// \t\t\t\t}\n\n// \t\t\t\t// Mute dead players for still living players\n// \t\t\t\tif (!localPLayer.isDead && other.isDead) {\n// \t\t\t\t\tgain.gain.value = 0;\n// \t\t\t\t}\n\n// \t\t\t\tbreak;\n\n// \t\t\tcase GameState.DISCUSSION:\n// \t\t\t\tpanPos = [0, 0];\n// \t\t\t\tgain.gain.value = 1;\n\n// \t\t\t\t// Mute dead players for still living players\n// \t\t\t\tif (!localPLayer.isDead && other.isDead) {\n// \t\t\t\t\tgain.gain.value = 0;\n// \t\t\t\t}\n// \t\t\t\tbreak;\n\n// \t\t\tcase GameState.UNKNOWN:\n// \t\t\tdefault:\n// \t\t\t\tgain.gain.value = 0;\n// \t\t\t\tbreak;\n// \t\t}\n\n// \t\tpan.positionX.setValueAtTime(panPos[0], audioContext.currentTime);\n// \t\tpan.positionY.setValueAtTime(panPos[1], audioContext.currentTime);\n// \t\tpan.positionZ.setValueAtTime(-0.5, audioContext.currentTime);\n// \t}\n\n// \tdisconnect(socketElementmap: SocketElementMap) {\n// \t\tthis.stream.getTracks().forEach((track) => track.stop());\n// \t\tsocketElementmap.forEach((value) => this.disconnectElement(value));\n// \t}\n\n// \tdisconnectElement(socketElement: SocketElement) {\n// \t\tif (!socketElement.audioElement) {\n// \t\t\treturn;\n// \t\t}\n// \t\tsocketElement?.audioElement?.compressor?.disconnect();\n// \t\tsocketElement?.audioElement?.pan?.disconnect();\n// \t\tsocketElement?.audioElement?.gain?.disconnect();\n// \t\tsocketElement?.audioElement?.mediaStreamAudioSource?.disconnect();\n// \t\tsocketElement?.audioElement?.audioContext\n// \t\t\t?.close()\n// \t\t\t.then(() => {})\n// \t\t\t.catch(() => {});\n// \t\tsocketElement?.audioElement?.htmlAudioElement.remove();\n// \t\tsocketElement.peer?.destroy();\n// \t\tsocketElement.audioElement = undefined;\n// \t\tsocketElement.peer = undefined;\n// \t}\n\n// \tasync getDevices(): Promise<IDeviceInfo[]> {\n// \t\tlet deviceId = 0;\n// \t\treturn (await navigator.mediaDevices.enumerateDevices())\n// \t\t\t.filter((o) => o.kind === 'audiooutput')\n// \t\t\t.map((o) => {\n// \t\t\t\treturn {\n// \t\t\t\t\tlabel: o.label || `Microphone ${deviceId++}`,\n// \t\t\t\t\tdeviceId: o.deviceId,\n// \t\t\t\t};\n// \t\t\t});\n// \t}\n// }\n\n// export const audioController = new AudioController();\n"]}